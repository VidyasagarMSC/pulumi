# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities
from . import outputs

__all__ = [
    'GetIsNetworkAclRuleResult',
    'AwaitableGetIsNetworkAclRuleResult',
    'get_is_network_acl_rule',
    'get_is_network_acl_rule_output',
]

@pulumi.output_type
class GetIsNetworkAclRuleResult:
    """
    A collection of values returned by getIsNetworkAclRule.
    """
    def __init__(__self__, action=None, before=None, destination=None, direction=None, href=None, icmps=None, id=None, ip_version=None, name=None, network_acl=None, protocol=None, rule_id=None, source=None, tcps=None, udps=None):
        if action and not isinstance(action, str):
            raise TypeError("Expected argument 'action' to be a str")
        pulumi.set(__self__, "action", action)
        if before and not isinstance(before, str):
            raise TypeError("Expected argument 'before' to be a str")
        pulumi.set(__self__, "before", before)
        if destination and not isinstance(destination, str):
            raise TypeError("Expected argument 'destination' to be a str")
        pulumi.set(__self__, "destination", destination)
        if direction and not isinstance(direction, str):
            raise TypeError("Expected argument 'direction' to be a str")
        pulumi.set(__self__, "direction", direction)
        if href and not isinstance(href, str):
            raise TypeError("Expected argument 'href' to be a str")
        pulumi.set(__self__, "href", href)
        if icmps and not isinstance(icmps, list):
            raise TypeError("Expected argument 'icmps' to be a list")
        pulumi.set(__self__, "icmps", icmps)
        if id and not isinstance(id, str):
            raise TypeError("Expected argument 'id' to be a str")
        pulumi.set(__self__, "id", id)
        if ip_version and not isinstance(ip_version, str):
            raise TypeError("Expected argument 'ip_version' to be a str")
        pulumi.set(__self__, "ip_version", ip_version)
        if name and not isinstance(name, str):
            raise TypeError("Expected argument 'name' to be a str")
        pulumi.set(__self__, "name", name)
        if network_acl and not isinstance(network_acl, str):
            raise TypeError("Expected argument 'network_acl' to be a str")
        pulumi.set(__self__, "network_acl", network_acl)
        if protocol and not isinstance(protocol, str):
            raise TypeError("Expected argument 'protocol' to be a str")
        pulumi.set(__self__, "protocol", protocol)
        if rule_id and not isinstance(rule_id, str):
            raise TypeError("Expected argument 'rule_id' to be a str")
        pulumi.set(__self__, "rule_id", rule_id)
        if source and not isinstance(source, str):
            raise TypeError("Expected argument 'source' to be a str")
        pulumi.set(__self__, "source", source)
        if tcps and not isinstance(tcps, list):
            raise TypeError("Expected argument 'tcps' to be a list")
        pulumi.set(__self__, "tcps", tcps)
        if udps and not isinstance(udps, list):
            raise TypeError("Expected argument 'udps' to be a list")
        pulumi.set(__self__, "udps", udps)

    @_builtins.property
    @pulumi.getter
    def action(self) -> _builtins.str:
        return pulumi.get(self, "action")

    @_builtins.property
    @pulumi.getter
    def before(self) -> _builtins.str:
        return pulumi.get(self, "before")

    @_builtins.property
    @pulumi.getter
    def destination(self) -> _builtins.str:
        return pulumi.get(self, "destination")

    @_builtins.property
    @pulumi.getter
    def direction(self) -> _builtins.str:
        return pulumi.get(self, "direction")

    @_builtins.property
    @pulumi.getter
    def href(self) -> _builtins.str:
        return pulumi.get(self, "href")

    @_builtins.property
    @pulumi.getter
    def icmps(self) -> Sequence['outputs.GetIsNetworkAclRuleIcmpResult']:
        return pulumi.get(self, "icmps")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="ipVersion")
    def ip_version(self) -> _builtins.str:
        return pulumi.get(self, "ip_version")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="networkAcl")
    def network_acl(self) -> _builtins.str:
        return pulumi.get(self, "network_acl")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> _builtins.str:
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter(name="ruleId")
    def rule_id(self) -> _builtins.str:
        return pulumi.get(self, "rule_id")

    @_builtins.property
    @pulumi.getter
    def source(self) -> _builtins.str:
        return pulumi.get(self, "source")

    @_builtins.property
    @pulumi.getter
    def tcps(self) -> Sequence['outputs.GetIsNetworkAclRuleTcpResult']:
        return pulumi.get(self, "tcps")

    @_builtins.property
    @pulumi.getter
    def udps(self) -> Sequence['outputs.GetIsNetworkAclRuleUdpResult']:
        return pulumi.get(self, "udps")


class AwaitableGetIsNetworkAclRuleResult(GetIsNetworkAclRuleResult):
    # pylint: disable=using-constant-test
    def __await__(self):
        if False:
            yield self
        return GetIsNetworkAclRuleResult(
            action=self.action,
            before=self.before,
            destination=self.destination,
            direction=self.direction,
            href=self.href,
            icmps=self.icmps,
            id=self.id,
            ip_version=self.ip_version,
            name=self.name,
            network_acl=self.network_acl,
            protocol=self.protocol,
            rule_id=self.rule_id,
            source=self.source,
            tcps=self.tcps,
            udps=self.udps)


def get_is_network_acl_rule(id: Optional[_builtins.str] = None,
                            name: Optional[_builtins.str] = None,
                            network_acl: Optional[_builtins.str] = None,
                            opts: Optional[pulumi.InvokeOptions] = None) -> AwaitableGetIsNetworkAclRuleResult:
    """
    Use this data source to access information about an existing resource.
    """
    __args__ = dict()
    __args__['id'] = id
    __args__['name'] = name
    __args__['networkAcl'] = network_acl
    opts = pulumi.InvokeOptions.merge(_utilities.get_invoke_opts_defaults(), opts)
    __ret__ = pulumi.runtime.invoke('ibm:index/getIsNetworkAclRule:getIsNetworkAclRule', __args__, opts=opts, typ=GetIsNetworkAclRuleResult, package_ref=_utilities.get_package()).value

    return AwaitableGetIsNetworkAclRuleResult(
        action=pulumi.get(__ret__, 'action'),
        before=pulumi.get(__ret__, 'before'),
        destination=pulumi.get(__ret__, 'destination'),
        direction=pulumi.get(__ret__, 'direction'),
        href=pulumi.get(__ret__, 'href'),
        icmps=pulumi.get(__ret__, 'icmps'),
        id=pulumi.get(__ret__, 'id'),
        ip_version=pulumi.get(__ret__, 'ip_version'),
        name=pulumi.get(__ret__, 'name'),
        network_acl=pulumi.get(__ret__, 'network_acl'),
        protocol=pulumi.get(__ret__, 'protocol'),
        rule_id=pulumi.get(__ret__, 'rule_id'),
        source=pulumi.get(__ret__, 'source'),
        tcps=pulumi.get(__ret__, 'tcps'),
        udps=pulumi.get(__ret__, 'udps'))
def get_is_network_acl_rule_output(id: Optional[pulumi.Input[Optional[_builtins.str]]] = None,
                                   name: Optional[pulumi.Input[_builtins.str]] = None,
                                   network_acl: Optional[pulumi.Input[_builtins.str]] = None,
                                   opts: Optional[Union[pulumi.InvokeOptions, pulumi.InvokeOutputOptions]] = None) -> pulumi.Output[GetIsNetworkAclRuleResult]:
    """
    Use this data source to access information about an existing resource.
    """
    __args__ = dict()
    __args__['id'] = id
    __args__['name'] = name
    __args__['networkAcl'] = network_acl
    opts = pulumi.InvokeOutputOptions.merge(_utilities.get_invoke_opts_defaults(), opts)
    __ret__ = pulumi.runtime.invoke_output('ibm:index/getIsNetworkAclRule:getIsNetworkAclRule', __args__, opts=opts, typ=GetIsNetworkAclRuleResult, package_ref=_utilities.get_package())
    return __ret__.apply(lambda __response__: GetIsNetworkAclRuleResult(
        action=pulumi.get(__response__, 'action'),
        before=pulumi.get(__response__, 'before'),
        destination=pulumi.get(__response__, 'destination'),
        direction=pulumi.get(__response__, 'direction'),
        href=pulumi.get(__response__, 'href'),
        icmps=pulumi.get(__response__, 'icmps'),
        id=pulumi.get(__response__, 'id'),
        ip_version=pulumi.get(__response__, 'ip_version'),
        name=pulumi.get(__response__, 'name'),
        network_acl=pulumi.get(__response__, 'network_acl'),
        protocol=pulumi.get(__response__, 'protocol'),
        rule_id=pulumi.get(__response__, 'rule_id'),
        source=pulumi.get(__response__, 'source'),
        tcps=pulumi.get(__response__, 'tcps'),
        udps=pulumi.get(__response__, 'udps')))
