# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities
from . import outputs
from ._inputs import *

__all__ = ['KmsKeyArgs', 'KmsKey']

@pulumi.input_type
class KmsKeyArgs:
    def __init__(__self__, *,
                 instance_id: pulumi.Input[_builtins.str],
                 key_name: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 encrypted_nonce: Optional[pulumi.Input[_builtins.str]] = None,
                 endpoint_type: Optional[pulumi.Input[_builtins.str]] = None,
                 expiration_date: Optional[pulumi.Input[_builtins.str]] = None,
                 force_delete: Optional[pulumi.Input[_builtins.bool]] = None,
                 iv_value: Optional[pulumi.Input[_builtins.str]] = None,
                 key_ring_id: Optional[pulumi.Input[_builtins.str]] = None,
                 kms_key_id: Optional[pulumi.Input[_builtins.str]] = None,
                 payload: Optional[pulumi.Input[_builtins.str]] = None,
                 standard_key: Optional[pulumi.Input[_builtins.bool]] = None,
                 timeouts: Optional[pulumi.Input['KmsKeyTimeoutsArgs']] = None):
        """
        The set of arguments for constructing a KmsKey resource.
        :param pulumi.Input[_builtins.str] instance_id: Key protect or hpcs instance GUID or CRN
        :param pulumi.Input[_builtins.str] key_name: Key name
        :param pulumi.Input[_builtins.str] description: description of the key
        :param pulumi.Input[_builtins.str] encrypted_nonce: Only for imported root key
        :param pulumi.Input[_builtins.str] endpoint_type: public or private
        :param pulumi.Input[_builtins.str] expiration_date: The date and time that the key expires in the system, in RFC 3339 format (YYYY-MM-DD HH:MM:SS.SS, for example
               2019-10-12T07:20:50.52Z). Use caution when setting an expiration date, as keys created with an expiration date
               automatically transition to the Deactivated state within one hour after expiration. In this state, the only allowed
               actions on the key are unwrap, rewrap, rotate, and delete. Deactivated keys cannot be used to encrypt (wrap) new data,
               even if rotated while deactivated. Rotation does not reset or extend the expiration date, nor does it allow the date to
               be changed. It is recommended that any data encrypted with an expiring or expired key be re-encrypted using a new
               customer root key (CRK) before the original CRK expires, to prevent service disruptions. Deleting and restoring a
               deactivated key does not move it back to the Active state. If the expiration_date attribute is omitted, the key does not
               expire.
        :param pulumi.Input[_builtins.bool] force_delete: set to true to force delete the key
        :param pulumi.Input[_builtins.str] iv_value: Only for imported root key
        :param pulumi.Input[_builtins.str] key_ring_id: Key Ring for the Key
        :param pulumi.Input[_builtins.bool] standard_key: Standard key type
        """
        pulumi.set(__self__, "instance_id", instance_id)
        pulumi.set(__self__, "key_name", key_name)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_nonce is not None:
            pulumi.set(__self__, "encrypted_nonce", encrypted_nonce)
        if endpoint_type is not None:
            pulumi.set(__self__, "endpoint_type", endpoint_type)
        if expiration_date is not None:
            pulumi.set(__self__, "expiration_date", expiration_date)
        if force_delete is not None:
            pulumi.set(__self__, "force_delete", force_delete)
        if iv_value is not None:
            pulumi.set(__self__, "iv_value", iv_value)
        if key_ring_id is not None:
            pulumi.set(__self__, "key_ring_id", key_ring_id)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if payload is not None:
            pulumi.set(__self__, "payload", payload)
        if standard_key is not None:
            pulumi.set(__self__, "standard_key", standard_key)
        if timeouts is not None:
            pulumi.set(__self__, "timeouts", timeouts)

    @_builtins.property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> pulumi.Input[_builtins.str]:
        """
        Key protect or hpcs instance GUID or CRN
        """
        return pulumi.get(self, "instance_id")

    @instance_id.setter
    def instance_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "instance_id", value)

    @_builtins.property
    @pulumi.getter(name="keyName")
    def key_name(self) -> pulumi.Input[_builtins.str]:
        """
        Key name
        """
        return pulumi.get(self, "key_name")

    @key_name.setter
    def key_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key_name", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        description of the key
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="encryptedNonce")
    def encrypted_nonce(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Only for imported root key
        """
        return pulumi.get(self, "encrypted_nonce")

    @encrypted_nonce.setter
    def encrypted_nonce(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "encrypted_nonce", value)

    @_builtins.property
    @pulumi.getter(name="endpointType")
    def endpoint_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        public or private
        """
        return pulumi.get(self, "endpoint_type")

    @endpoint_type.setter
    def endpoint_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "endpoint_type", value)

    @_builtins.property
    @pulumi.getter(name="expirationDate")
    def expiration_date(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The date and time that the key expires in the system, in RFC 3339 format (YYYY-MM-DD HH:MM:SS.SS, for example
        2019-10-12T07:20:50.52Z). Use caution when setting an expiration date, as keys created with an expiration date
        automatically transition to the Deactivated state within one hour after expiration. In this state, the only allowed
        actions on the key are unwrap, rewrap, rotate, and delete. Deactivated keys cannot be used to encrypt (wrap) new data,
        even if rotated while deactivated. Rotation does not reset or extend the expiration date, nor does it allow the date to
        be changed. It is recommended that any data encrypted with an expiring or expired key be re-encrypted using a new
        customer root key (CRK) before the original CRK expires, to prevent service disruptions. Deleting and restoring a
        deactivated key does not move it back to the Active state. If the expiration_date attribute is omitted, the key does not
        expire.
        """
        return pulumi.get(self, "expiration_date")

    @expiration_date.setter
    def expiration_date(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "expiration_date", value)

    @_builtins.property
    @pulumi.getter(name="forceDelete")
    def force_delete(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        set to true to force delete the key
        """
        return pulumi.get(self, "force_delete")

    @force_delete.setter
    def force_delete(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "force_delete", value)

    @_builtins.property
    @pulumi.getter(name="ivValue")
    def iv_value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Only for imported root key
        """
        return pulumi.get(self, "iv_value")

    @iv_value.setter
    def iv_value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "iv_value", value)

    @_builtins.property
    @pulumi.getter(name="keyRingId")
    def key_ring_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Key Ring for the Key
        """
        return pulumi.get(self, "key_ring_id")

    @key_ring_id.setter
    def key_ring_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key_ring_id", value)

    @_builtins.property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "kms_key_id")

    @kms_key_id.setter
    def kms_key_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "kms_key_id", value)

    @_builtins.property
    @pulumi.getter
    def payload(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "payload")

    @payload.setter
    def payload(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "payload", value)

    @_builtins.property
    @pulumi.getter(name="standardKey")
    def standard_key(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Standard key type
        """
        return pulumi.get(self, "standard_key")

    @standard_key.setter
    def standard_key(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "standard_key", value)

    @_builtins.property
    @pulumi.getter
    def timeouts(self) -> Optional[pulumi.Input['KmsKeyTimeoutsArgs']]:
        return pulumi.get(self, "timeouts")

    @timeouts.setter
    def timeouts(self, value: Optional[pulumi.Input['KmsKeyTimeoutsArgs']]):
        pulumi.set(self, "timeouts", value)


@pulumi.input_type
class _KmsKeyState:
    def __init__(__self__, *,
                 crn: Optional[pulumi.Input[_builtins.str]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 encrypted_nonce: Optional[pulumi.Input[_builtins.str]] = None,
                 endpoint_type: Optional[pulumi.Input[_builtins.str]] = None,
                 expiration_date: Optional[pulumi.Input[_builtins.str]] = None,
                 force_delete: Optional[pulumi.Input[_builtins.bool]] = None,
                 instance_crn: Optional[pulumi.Input[_builtins.str]] = None,
                 instance_id: Optional[pulumi.Input[_builtins.str]] = None,
                 iv_value: Optional[pulumi.Input[_builtins.str]] = None,
                 key_id: Optional[pulumi.Input[_builtins.str]] = None,
                 key_name: Optional[pulumi.Input[_builtins.str]] = None,
                 key_ring_id: Optional[pulumi.Input[_builtins.str]] = None,
                 kms_key_id: Optional[pulumi.Input[_builtins.str]] = None,
                 payload: Optional[pulumi.Input[_builtins.str]] = None,
                 registrations: Optional[pulumi.Input[Sequence[pulumi.Input['KmsKeyRegistrationArgs']]]] = None,
                 resource_controller_url: Optional[pulumi.Input[_builtins.str]] = None,
                 resource_crn: Optional[pulumi.Input[_builtins.str]] = None,
                 resource_group_name: Optional[pulumi.Input[_builtins.str]] = None,
                 resource_name: Optional[pulumi.Input[_builtins.str]] = None,
                 resource_status: Optional[pulumi.Input[_builtins.str]] = None,
                 standard_key: Optional[pulumi.Input[_builtins.bool]] = None,
                 timeouts: Optional[pulumi.Input['KmsKeyTimeoutsArgs']] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        Input properties used for looking up and filtering KmsKey resources.
        :param pulumi.Input[_builtins.str] crn: Crn of the key
        :param pulumi.Input[_builtins.str] description: description of the key
        :param pulumi.Input[_builtins.str] encrypted_nonce: Only for imported root key
        :param pulumi.Input[_builtins.str] endpoint_type: public or private
        :param pulumi.Input[_builtins.str] expiration_date: The date and time that the key expires in the system, in RFC 3339 format (YYYY-MM-DD HH:MM:SS.SS, for example
               2019-10-12T07:20:50.52Z). Use caution when setting an expiration date, as keys created with an expiration date
               automatically transition to the Deactivated state within one hour after expiration. In this state, the only allowed
               actions on the key are unwrap, rewrap, rotate, and delete. Deactivated keys cannot be used to encrypt (wrap) new data,
               even if rotated while deactivated. Rotation does not reset or extend the expiration date, nor does it allow the date to
               be changed. It is recommended that any data encrypted with an expiring or expired key be re-encrypted using a new
               customer root key (CRK) before the original CRK expires, to prevent service disruptions. Deleting and restoring a
               deactivated key does not move it back to the Active state. If the expiration_date attribute is omitted, the key does not
               expire.
        :param pulumi.Input[_builtins.bool] force_delete: set to true to force delete the key
        :param pulumi.Input[_builtins.str] instance_crn: Key protect or hpcs instance CRN
        :param pulumi.Input[_builtins.str] instance_id: Key protect or hpcs instance GUID or CRN
        :param pulumi.Input[_builtins.str] iv_value: Only for imported root key
        :param pulumi.Input[_builtins.str] key_id: Key ID
        :param pulumi.Input[_builtins.str] key_name: Key name
        :param pulumi.Input[_builtins.str] key_ring_id: Key Ring for the Key
        :param pulumi.Input[Sequence[pulumi.Input['KmsKeyRegistrationArgs']]] registrations: Registrations of the key across different services
        :param pulumi.Input[_builtins.str] resource_controller_url: The URL of the IBM Cloud dashboard that can be used to explore and view details about the resource
        :param pulumi.Input[_builtins.str] resource_crn: The crn of the resource
        :param pulumi.Input[_builtins.str] resource_group_name: The resource group name in which resource is provisioned
        :param pulumi.Input[_builtins.str] resource_name: The name of the resource
        :param pulumi.Input[_builtins.str] resource_status: The status of the resource
        :param pulumi.Input[_builtins.bool] standard_key: Standard key type
        :param pulumi.Input[_builtins.str] type: type of service hs-crypto or kms
        """
        if crn is not None:
            pulumi.set(__self__, "crn", crn)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if encrypted_nonce is not None:
            pulumi.set(__self__, "encrypted_nonce", encrypted_nonce)
        if endpoint_type is not None:
            pulumi.set(__self__, "endpoint_type", endpoint_type)
        if expiration_date is not None:
            pulumi.set(__self__, "expiration_date", expiration_date)
        if force_delete is not None:
            pulumi.set(__self__, "force_delete", force_delete)
        if instance_crn is not None:
            pulumi.set(__self__, "instance_crn", instance_crn)
        if instance_id is not None:
            pulumi.set(__self__, "instance_id", instance_id)
        if iv_value is not None:
            pulumi.set(__self__, "iv_value", iv_value)
        if key_id is not None:
            pulumi.set(__self__, "key_id", key_id)
        if key_name is not None:
            pulumi.set(__self__, "key_name", key_name)
        if key_ring_id is not None:
            pulumi.set(__self__, "key_ring_id", key_ring_id)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if payload is not None:
            pulumi.set(__self__, "payload", payload)
        if registrations is not None:
            pulumi.set(__self__, "registrations", registrations)
        if resource_controller_url is not None:
            pulumi.set(__self__, "resource_controller_url", resource_controller_url)
        if resource_crn is not None:
            pulumi.set(__self__, "resource_crn", resource_crn)
        if resource_group_name is not None:
            pulumi.set(__self__, "resource_group_name", resource_group_name)
        if resource_name is not None:
            pulumi.set(__self__, "resource_name", resource_name)
        if resource_status is not None:
            pulumi.set(__self__, "resource_status", resource_status)
        if standard_key is not None:
            pulumi.set(__self__, "standard_key", standard_key)
        if timeouts is not None:
            pulumi.set(__self__, "timeouts", timeouts)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def crn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Crn of the key
        """
        return pulumi.get(self, "crn")

    @crn.setter
    def crn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "crn", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        description of the key
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="encryptedNonce")
    def encrypted_nonce(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Only for imported root key
        """
        return pulumi.get(self, "encrypted_nonce")

    @encrypted_nonce.setter
    def encrypted_nonce(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "encrypted_nonce", value)

    @_builtins.property
    @pulumi.getter(name="endpointType")
    def endpoint_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        public or private
        """
        return pulumi.get(self, "endpoint_type")

    @endpoint_type.setter
    def endpoint_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "endpoint_type", value)

    @_builtins.property
    @pulumi.getter(name="expirationDate")
    def expiration_date(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The date and time that the key expires in the system, in RFC 3339 format (YYYY-MM-DD HH:MM:SS.SS, for example
        2019-10-12T07:20:50.52Z). Use caution when setting an expiration date, as keys created with an expiration date
        automatically transition to the Deactivated state within one hour after expiration. In this state, the only allowed
        actions on the key are unwrap, rewrap, rotate, and delete. Deactivated keys cannot be used to encrypt (wrap) new data,
        even if rotated while deactivated. Rotation does not reset or extend the expiration date, nor does it allow the date to
        be changed. It is recommended that any data encrypted with an expiring or expired key be re-encrypted using a new
        customer root key (CRK) before the original CRK expires, to prevent service disruptions. Deleting and restoring a
        deactivated key does not move it back to the Active state. If the expiration_date attribute is omitted, the key does not
        expire.
        """
        return pulumi.get(self, "expiration_date")

    @expiration_date.setter
    def expiration_date(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "expiration_date", value)

    @_builtins.property
    @pulumi.getter(name="forceDelete")
    def force_delete(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        set to true to force delete the key
        """
        return pulumi.get(self, "force_delete")

    @force_delete.setter
    def force_delete(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "force_delete", value)

    @_builtins.property
    @pulumi.getter(name="instanceCrn")
    def instance_crn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Key protect or hpcs instance CRN
        """
        return pulumi.get(self, "instance_crn")

    @instance_crn.setter
    def instance_crn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "instance_crn", value)

    @_builtins.property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Key protect or hpcs instance GUID or CRN
        """
        return pulumi.get(self, "instance_id")

    @instance_id.setter
    def instance_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "instance_id", value)

    @_builtins.property
    @pulumi.getter(name="ivValue")
    def iv_value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Only for imported root key
        """
        return pulumi.get(self, "iv_value")

    @iv_value.setter
    def iv_value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "iv_value", value)

    @_builtins.property
    @pulumi.getter(name="keyId")
    def key_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Key ID
        """
        return pulumi.get(self, "key_id")

    @key_id.setter
    def key_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key_id", value)

    @_builtins.property
    @pulumi.getter(name="keyName")
    def key_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Key name
        """
        return pulumi.get(self, "key_name")

    @key_name.setter
    def key_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key_name", value)

    @_builtins.property
    @pulumi.getter(name="keyRingId")
    def key_ring_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Key Ring for the Key
        """
        return pulumi.get(self, "key_ring_id")

    @key_ring_id.setter
    def key_ring_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key_ring_id", value)

    @_builtins.property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "kms_key_id")

    @kms_key_id.setter
    def kms_key_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "kms_key_id", value)

    @_builtins.property
    @pulumi.getter
    def payload(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "payload")

    @payload.setter
    def payload(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "payload", value)

    @_builtins.property
    @pulumi.getter
    def registrations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KmsKeyRegistrationArgs']]]]:
        """
        Registrations of the key across different services
        """
        return pulumi.get(self, "registrations")

    @registrations.setter
    def registrations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KmsKeyRegistrationArgs']]]]):
        pulumi.set(self, "registrations", value)

    @_builtins.property
    @pulumi.getter(name="resourceControllerUrl")
    def resource_controller_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The URL of the IBM Cloud dashboard that can be used to explore and view details about the resource
        """
        return pulumi.get(self, "resource_controller_url")

    @resource_controller_url.setter
    def resource_controller_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "resource_controller_url", value)

    @_builtins.property
    @pulumi.getter(name="resourceCrn")
    def resource_crn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The crn of the resource
        """
        return pulumi.get(self, "resource_crn")

    @resource_crn.setter
    def resource_crn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "resource_crn", value)

    @_builtins.property
    @pulumi.getter(name="resourceGroupName")
    def resource_group_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The resource group name in which resource is provisioned
        """
        return pulumi.get(self, "resource_group_name")

    @resource_group_name.setter
    def resource_group_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "resource_group_name", value)

    @_builtins.property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the resource
        """
        return pulumi.get(self, "resource_name")

    @resource_name.setter
    def resource_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "resource_name", value)

    @_builtins.property
    @pulumi.getter(name="resourceStatus")
    def resource_status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The status of the resource
        """
        return pulumi.get(self, "resource_status")

    @resource_status.setter
    def resource_status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "resource_status", value)

    @_builtins.property
    @pulumi.getter(name="standardKey")
    def standard_key(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Standard key type
        """
        return pulumi.get(self, "standard_key")

    @standard_key.setter
    def standard_key(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "standard_key", value)

    @_builtins.property
    @pulumi.getter
    def timeouts(self) -> Optional[pulumi.Input['KmsKeyTimeoutsArgs']]:
        return pulumi.get(self, "timeouts")

    @timeouts.setter
    def timeouts(self, value: Optional[pulumi.Input['KmsKeyTimeoutsArgs']]):
        pulumi.set(self, "timeouts", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        type of service hs-crypto or kms
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


@pulumi.type_token("ibm:index/kmsKey:KmsKey")
class KmsKey(pulumi.CustomResource):
    @overload
    def __init__(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 encrypted_nonce: Optional[pulumi.Input[_builtins.str]] = None,
                 endpoint_type: Optional[pulumi.Input[_builtins.str]] = None,
                 expiration_date: Optional[pulumi.Input[_builtins.str]] = None,
                 force_delete: Optional[pulumi.Input[_builtins.bool]] = None,
                 instance_id: Optional[pulumi.Input[_builtins.str]] = None,
                 iv_value: Optional[pulumi.Input[_builtins.str]] = None,
                 key_name: Optional[pulumi.Input[_builtins.str]] = None,
                 key_ring_id: Optional[pulumi.Input[_builtins.str]] = None,
                 kms_key_id: Optional[pulumi.Input[_builtins.str]] = None,
                 payload: Optional[pulumi.Input[_builtins.str]] = None,
                 standard_key: Optional[pulumi.Input[_builtins.bool]] = None,
                 timeouts: Optional[pulumi.Input[Union['KmsKeyTimeoutsArgs', 'KmsKeyTimeoutsArgsDict']]] = None,
                 __props__=None):
        """
        Create a KmsKey resource with the given unique name, props, and options.
        :param str resource_name: The name of the resource.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[_builtins.str] description: description of the key
        :param pulumi.Input[_builtins.str] encrypted_nonce: Only for imported root key
        :param pulumi.Input[_builtins.str] endpoint_type: public or private
        :param pulumi.Input[_builtins.str] expiration_date: The date and time that the key expires in the system, in RFC 3339 format (YYYY-MM-DD HH:MM:SS.SS, for example
               2019-10-12T07:20:50.52Z). Use caution when setting an expiration date, as keys created with an expiration date
               automatically transition to the Deactivated state within one hour after expiration. In this state, the only allowed
               actions on the key are unwrap, rewrap, rotate, and delete. Deactivated keys cannot be used to encrypt (wrap) new data,
               even if rotated while deactivated. Rotation does not reset or extend the expiration date, nor does it allow the date to
               be changed. It is recommended that any data encrypted with an expiring or expired key be re-encrypted using a new
               customer root key (CRK) before the original CRK expires, to prevent service disruptions. Deleting and restoring a
               deactivated key does not move it back to the Active state. If the expiration_date attribute is omitted, the key does not
               expire.
        :param pulumi.Input[_builtins.bool] force_delete: set to true to force delete the key
        :param pulumi.Input[_builtins.str] instance_id: Key protect or hpcs instance GUID or CRN
        :param pulumi.Input[_builtins.str] iv_value: Only for imported root key
        :param pulumi.Input[_builtins.str] key_name: Key name
        :param pulumi.Input[_builtins.str] key_ring_id: Key Ring for the Key
        :param pulumi.Input[_builtins.bool] standard_key: Standard key type
        """
        ...
    @overload
    def __init__(__self__,
                 resource_name: str,
                 args: KmsKeyArgs,
                 opts: Optional[pulumi.ResourceOptions] = None):
        """
        Create a KmsKey resource with the given unique name, props, and options.
        :param str resource_name: The name of the resource.
        :param KmsKeyArgs args: The arguments to use to populate this resource's properties.
        :param pulumi.ResourceOptions opts: Options for the resource.
        """
        ...
    def __init__(__self__, resource_name: str, *args, **kwargs):
        resource_args, opts = _utilities.get_resource_args_opts(KmsKeyArgs, pulumi.ResourceOptions, *args, **kwargs)
        if resource_args is not None:
            __self__._internal_init(resource_name, opts, **resource_args.__dict__)
        else:
            __self__._internal_init(resource_name, *args, **kwargs)

    def _internal_init(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 encrypted_nonce: Optional[pulumi.Input[_builtins.str]] = None,
                 endpoint_type: Optional[pulumi.Input[_builtins.str]] = None,
                 expiration_date: Optional[pulumi.Input[_builtins.str]] = None,
                 force_delete: Optional[pulumi.Input[_builtins.bool]] = None,
                 instance_id: Optional[pulumi.Input[_builtins.str]] = None,
                 iv_value: Optional[pulumi.Input[_builtins.str]] = None,
                 key_name: Optional[pulumi.Input[_builtins.str]] = None,
                 key_ring_id: Optional[pulumi.Input[_builtins.str]] = None,
                 kms_key_id: Optional[pulumi.Input[_builtins.str]] = None,
                 payload: Optional[pulumi.Input[_builtins.str]] = None,
                 standard_key: Optional[pulumi.Input[_builtins.bool]] = None,
                 timeouts: Optional[pulumi.Input[Union['KmsKeyTimeoutsArgs', 'KmsKeyTimeoutsArgsDict']]] = None,
                 __props__=None):
        opts = pulumi.ResourceOptions.merge(_utilities.get_resource_opts_defaults(), opts)
        if not isinstance(opts, pulumi.ResourceOptions):
            raise TypeError('Expected resource options to be a ResourceOptions instance')
        if opts.id is None:
            if __props__ is not None:
                raise TypeError('__props__ is only valid when passed in combination with a valid opts.id to get an existing resource')
            __props__ = KmsKeyArgs.__new__(KmsKeyArgs)

            __props__.__dict__["description"] = description
            __props__.__dict__["encrypted_nonce"] = encrypted_nonce
            __props__.__dict__["endpoint_type"] = endpoint_type
            __props__.__dict__["expiration_date"] = expiration_date
            __props__.__dict__["force_delete"] = force_delete
            if instance_id is None and not opts.urn:
                raise TypeError("Missing required property 'instance_id'")
            __props__.__dict__["instance_id"] = instance_id
            __props__.__dict__["iv_value"] = iv_value
            if key_name is None and not opts.urn:
                raise TypeError("Missing required property 'key_name'")
            __props__.__dict__["key_name"] = key_name
            __props__.__dict__["key_ring_id"] = key_ring_id
            __props__.__dict__["kms_key_id"] = kms_key_id
            __props__.__dict__["payload"] = None if payload is None else pulumi.Output.secret(payload)
            __props__.__dict__["standard_key"] = standard_key
            __props__.__dict__["timeouts"] = timeouts
            __props__.__dict__["crn"] = None
            __props__.__dict__["instance_crn"] = None
            __props__.__dict__["key_id"] = None
            __props__.__dict__["registrations"] = None
            __props__.__dict__["resource_controller_url"] = None
            __props__.__dict__["resource_crn"] = None
            __props__.__dict__["resource_group_name"] = None
            __props__.__dict__["resource_name"] = None
            __props__.__dict__["resource_status"] = None
            __props__.__dict__["type"] = None
        secret_opts = pulumi.ResourceOptions(additional_secret_outputs=["payload"])
        opts = pulumi.ResourceOptions.merge(opts, secret_opts)
        super(KmsKey, __self__).__init__(
            'ibm:index/kmsKey:KmsKey',
            resource_name,
            __props__,
            opts,
            package_ref=_utilities.get_package())

    @staticmethod
    def get(resource_name: str,
            id: pulumi.Input[str],
            opts: Optional[pulumi.ResourceOptions] = None,
            crn: Optional[pulumi.Input[_builtins.str]] = None,
            description: Optional[pulumi.Input[_builtins.str]] = None,
            encrypted_nonce: Optional[pulumi.Input[_builtins.str]] = None,
            endpoint_type: Optional[pulumi.Input[_builtins.str]] = None,
            expiration_date: Optional[pulumi.Input[_builtins.str]] = None,
            force_delete: Optional[pulumi.Input[_builtins.bool]] = None,
            instance_crn: Optional[pulumi.Input[_builtins.str]] = None,
            instance_id: Optional[pulumi.Input[_builtins.str]] = None,
            iv_value: Optional[pulumi.Input[_builtins.str]] = None,
            key_id: Optional[pulumi.Input[_builtins.str]] = None,
            key_name: Optional[pulumi.Input[_builtins.str]] = None,
            key_ring_id: Optional[pulumi.Input[_builtins.str]] = None,
            kms_key_id: Optional[pulumi.Input[_builtins.str]] = None,
            payload: Optional[pulumi.Input[_builtins.str]] = None,
            registrations: Optional[pulumi.Input[Sequence[pulumi.Input[Union['KmsKeyRegistrationArgs', 'KmsKeyRegistrationArgsDict']]]]] = None,
            resource_controller_url: Optional[pulumi.Input[_builtins.str]] = None,
            resource_crn: Optional[pulumi.Input[_builtins.str]] = None,
            resource_group_name: Optional[pulumi.Input[_builtins.str]] = None,
            resource_name_: Optional[pulumi.Input[_builtins.str]] = None,
            resource_status: Optional[pulumi.Input[_builtins.str]] = None,
            standard_key: Optional[pulumi.Input[_builtins.bool]] = None,
            timeouts: Optional[pulumi.Input[Union['KmsKeyTimeoutsArgs', 'KmsKeyTimeoutsArgsDict']]] = None,
            type: Optional[pulumi.Input[_builtins.str]] = None) -> 'KmsKey':
        """
        Get an existing KmsKey resource's state with the given name, id, and optional extra
        properties used to qualify the lookup.

        :param str resource_name: The unique name of the resulting resource.
        :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[_builtins.str] crn: Crn of the key
        :param pulumi.Input[_builtins.str] description: description of the key
        :param pulumi.Input[_builtins.str] encrypted_nonce: Only for imported root key
        :param pulumi.Input[_builtins.str] endpoint_type: public or private
        :param pulumi.Input[_builtins.str] expiration_date: The date and time that the key expires in the system, in RFC 3339 format (YYYY-MM-DD HH:MM:SS.SS, for example
               2019-10-12T07:20:50.52Z). Use caution when setting an expiration date, as keys created with an expiration date
               automatically transition to the Deactivated state within one hour after expiration. In this state, the only allowed
               actions on the key are unwrap, rewrap, rotate, and delete. Deactivated keys cannot be used to encrypt (wrap) new data,
               even if rotated while deactivated. Rotation does not reset or extend the expiration date, nor does it allow the date to
               be changed. It is recommended that any data encrypted with an expiring or expired key be re-encrypted using a new
               customer root key (CRK) before the original CRK expires, to prevent service disruptions. Deleting and restoring a
               deactivated key does not move it back to the Active state. If the expiration_date attribute is omitted, the key does not
               expire.
        :param pulumi.Input[_builtins.bool] force_delete: set to true to force delete the key
        :param pulumi.Input[_builtins.str] instance_crn: Key protect or hpcs instance CRN
        :param pulumi.Input[_builtins.str] instance_id: Key protect or hpcs instance GUID or CRN
        :param pulumi.Input[_builtins.str] iv_value: Only for imported root key
        :param pulumi.Input[_builtins.str] key_id: Key ID
        :param pulumi.Input[_builtins.str] key_name: Key name
        :param pulumi.Input[_builtins.str] key_ring_id: Key Ring for the Key
        :param pulumi.Input[Sequence[pulumi.Input[Union['KmsKeyRegistrationArgs', 'KmsKeyRegistrationArgsDict']]]] registrations: Registrations of the key across different services
        :param pulumi.Input[_builtins.str] resource_controller_url: The URL of the IBM Cloud dashboard that can be used to explore and view details about the resource
        :param pulumi.Input[_builtins.str] resource_crn: The crn of the resource
        :param pulumi.Input[_builtins.str] resource_group_name: The resource group name in which resource is provisioned
        :param pulumi.Input[_builtins.str] resource_name_: The name of the resource
        :param pulumi.Input[_builtins.str] resource_status: The status of the resource
        :param pulumi.Input[_builtins.bool] standard_key: Standard key type
        :param pulumi.Input[_builtins.str] type: type of service hs-crypto or kms
        """
        opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))

        __props__ = _KmsKeyState.__new__(_KmsKeyState)

        __props__.__dict__["crn"] = crn
        __props__.__dict__["description"] = description
        __props__.__dict__["encrypted_nonce"] = encrypted_nonce
        __props__.__dict__["endpoint_type"] = endpoint_type
        __props__.__dict__["expiration_date"] = expiration_date
        __props__.__dict__["force_delete"] = force_delete
        __props__.__dict__["instance_crn"] = instance_crn
        __props__.__dict__["instance_id"] = instance_id
        __props__.__dict__["iv_value"] = iv_value
        __props__.__dict__["key_id"] = key_id
        __props__.__dict__["key_name"] = key_name
        __props__.__dict__["key_ring_id"] = key_ring_id
        __props__.__dict__["kms_key_id"] = kms_key_id
        __props__.__dict__["payload"] = payload
        __props__.__dict__["registrations"] = registrations
        __props__.__dict__["resource_controller_url"] = resource_controller_url
        __props__.__dict__["resource_crn"] = resource_crn
        __props__.__dict__["resource_group_name"] = resource_group_name
        __props__.__dict__["resource_name"] = resource_name_
        __props__.__dict__["resource_status"] = resource_status
        __props__.__dict__["standard_key"] = standard_key
        __props__.__dict__["timeouts"] = timeouts
        __props__.__dict__["type"] = type
        return KmsKey(resource_name, opts=opts, __props__=__props__)

    @_builtins.property
    @pulumi.getter
    def crn(self) -> pulumi.Output[_builtins.str]:
        """
        Crn of the key
        """
        return pulumi.get(self, "crn")

    @_builtins.property
    @pulumi.getter
    def description(self) -> pulumi.Output[Optional[_builtins.str]]:
        """
        description of the key
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="encryptedNonce")
    def encrypted_nonce(self) -> pulumi.Output[Optional[_builtins.str]]:
        """
        Only for imported root key
        """
        return pulumi.get(self, "encrypted_nonce")

    @_builtins.property
    @pulumi.getter(name="endpointType")
    def endpoint_type(self) -> pulumi.Output[_builtins.str]:
        """
        public or private
        """
        return pulumi.get(self, "endpoint_type")

    @_builtins.property
    @pulumi.getter(name="expirationDate")
    def expiration_date(self) -> pulumi.Output[Optional[_builtins.str]]:
        """
        The date and time that the key expires in the system, in RFC 3339 format (YYYY-MM-DD HH:MM:SS.SS, for example
        2019-10-12T07:20:50.52Z). Use caution when setting an expiration date, as keys created with an expiration date
        automatically transition to the Deactivated state within one hour after expiration. In this state, the only allowed
        actions on the key are unwrap, rewrap, rotate, and delete. Deactivated keys cannot be used to encrypt (wrap) new data,
        even if rotated while deactivated. Rotation does not reset or extend the expiration date, nor does it allow the date to
        be changed. It is recommended that any data encrypted with an expiring or expired key be re-encrypted using a new
        customer root key (CRK) before the original CRK expires, to prevent service disruptions. Deleting and restoring a
        deactivated key does not move it back to the Active state. If the expiration_date attribute is omitted, the key does not
        expire.
        """
        return pulumi.get(self, "expiration_date")

    @_builtins.property
    @pulumi.getter(name="forceDelete")
    def force_delete(self) -> pulumi.Output[Optional[_builtins.bool]]:
        """
        set to true to force delete the key
        """
        return pulumi.get(self, "force_delete")

    @_builtins.property
    @pulumi.getter(name="instanceCrn")
    def instance_crn(self) -> pulumi.Output[_builtins.str]:
        """
        Key protect or hpcs instance CRN
        """
        return pulumi.get(self, "instance_crn")

    @_builtins.property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> pulumi.Output[_builtins.str]:
        """
        Key protect or hpcs instance GUID or CRN
        """
        return pulumi.get(self, "instance_id")

    @_builtins.property
    @pulumi.getter(name="ivValue")
    def iv_value(self) -> pulumi.Output[Optional[_builtins.str]]:
        """
        Only for imported root key
        """
        return pulumi.get(self, "iv_value")

    @_builtins.property
    @pulumi.getter(name="keyId")
    def key_id(self) -> pulumi.Output[_builtins.str]:
        """
        Key ID
        """
        return pulumi.get(self, "key_id")

    @_builtins.property
    @pulumi.getter(name="keyName")
    def key_name(self) -> pulumi.Output[_builtins.str]:
        """
        Key name
        """
        return pulumi.get(self, "key_name")

    @_builtins.property
    @pulumi.getter(name="keyRingId")
    def key_ring_id(self) -> pulumi.Output[Optional[_builtins.str]]:
        """
        Key Ring for the Key
        """
        return pulumi.get(self, "key_ring_id")

    @_builtins.property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> pulumi.Output[_builtins.str]:
        return pulumi.get(self, "kms_key_id")

    @_builtins.property
    @pulumi.getter
    def payload(self) -> pulumi.Output[_builtins.str]:
        return pulumi.get(self, "payload")

    @_builtins.property
    @pulumi.getter
    def registrations(self) -> pulumi.Output[Sequence['outputs.KmsKeyRegistration']]:
        """
        Registrations of the key across different services
        """
        return pulumi.get(self, "registrations")

    @_builtins.property
    @pulumi.getter(name="resourceControllerUrl")
    def resource_controller_url(self) -> pulumi.Output[_builtins.str]:
        """
        The URL of the IBM Cloud dashboard that can be used to explore and view details about the resource
        """
        return pulumi.get(self, "resource_controller_url")

    @_builtins.property
    @pulumi.getter(name="resourceCrn")
    def resource_crn(self) -> pulumi.Output[_builtins.str]:
        """
        The crn of the resource
        """
        return pulumi.get(self, "resource_crn")

    @_builtins.property
    @pulumi.getter(name="resourceGroupName")
    def resource_group_name(self) -> pulumi.Output[_builtins.str]:
        """
        The resource group name in which resource is provisioned
        """
        return pulumi.get(self, "resource_group_name")

    @_builtins.property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> pulumi.Output[_builtins.str]:
        """
        The name of the resource
        """
        return pulumi.get(self, "resource_name")

    @_builtins.property
    @pulumi.getter(name="resourceStatus")
    def resource_status(self) -> pulumi.Output[_builtins.str]:
        """
        The status of the resource
        """
        return pulumi.get(self, "resource_status")

    @_builtins.property
    @pulumi.getter(name="standardKey")
    def standard_key(self) -> pulumi.Output[Optional[_builtins.bool]]:
        """
        Standard key type
        """
        return pulumi.get(self, "standard_key")

    @_builtins.property
    @pulumi.getter
    def timeouts(self) -> pulumi.Output[Optional['outputs.KmsKeyTimeouts']]:
        return pulumi.get(self, "timeouts")

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Output[_builtins.str]:
        """
        type of service hs-crypto or kms
        """
        return pulumi.get(self, "type")

